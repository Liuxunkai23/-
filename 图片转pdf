# -*- coding: utf-8 -*-
"""
将文件夹内的图片按修改时间顺序合并为一个 PDF 并保存到桌面。

用法示例：
	python 图片转pdf.py -i "C:/Users/you/Pictures/album" -o out.pdf --order asc

依赖：
	pip install pillow

功能：
 - 支持常见图片格式：jpg, jpeg, png, bmp, gif, tiff
 - 默认读取脚本当前目录（或可通过 -i 指定），按修改时间升序（asc）或降序（desc）排序
 - 输出文件默认放在当前用户桌面，文件名可通过 -o 指定
 - 会把 RGBA 图像转换为 RGB（以白色背景去除透明度）
"""

import argparse
import os
import sys
from datetime import datetime
from PIL import Image


def get_desktop_path():
	"""返回当前用户的桌面路径（Windows 环境）。"""
	home = os.path.expanduser("~")
	desktop = os.path.join(home, "Desktop")
	return desktop


def find_images(folder, recursive=False):
	"""遍历 folder，返回图片文件绝对路径列表（不包含子文件夹除非 recursive=True）。"""
	exts = {'.jpg', '.jpeg', '.png', '.bmp', '.gif', '.tif', '.tiff'}
	results = []
	if recursive:
		for root, _, files in os.walk(folder):
			for f in files:
				if os.path.splitext(f)[1].lower() in exts:
					results.append(os.path.join(root, f))
	else:
		try:
			for f in os.listdir(folder):
				path = os.path.join(folder, f)
				if os.path.isfile(path) and os.path.splitext(f)[1].lower() in exts:
					results.append(path)
		except FileNotFoundError:
			return []
	return results


def convert_images_to_pdf(image_paths, output_path):
	"""把按顺序的 image_paths 合并为一个 PDF，保存到 output_path。"""
	if not image_paths:
		raise ValueError("没有找到任何图片文件。")

	pil_images = []
	for p in image_paths:
		try:
			im = Image.open(p)
		except Exception as e:
			print(f"跳过无法打开的文件: {p} -> {e}")
			continue

		# Convert to RGB. Handle transparency by pasting on white background.
		if im.mode in ("RGBA", "LA") or (im.mode == "P" and 'transparency' in im.info):
			bg = Image.new("RGB", im.size, (255, 255, 255))
			try:
				bg.paste(im, mask=im.split()[3] if im.mode == 'RGBA' else None)
			except Exception:
				bg.paste(im)
			im = bg
		else:
			im = im.convert("RGB")

		pil_images.append(im)

	if not pil_images:
		raise ValueError("所有图片都无法打开或转换为 PDF。")

	first, rest = pil_images[0], pil_images[1:]
	# 保存到 PDF
	first.save(output_path, "PDF", resolution=100.0, save_all=True, append_images=rest)


def make_unique_path(path):
	"""如果 path 已存在，则在文件名后追加 _1, _2 ... 直到唯一，返回新的路径。"""
	if not os.path.exists(path):
		return path
	base, ext = os.path.splitext(path)
	i = 1
	while True:
		new_path = f"{base}_{i}{ext}"
		if not os.path.exists(new_path):
			return new_path
		i += 1


def parse_args():
	p = argparse.ArgumentParser(description="把文件夹内图片按修改时间排序合并为一个 PDF 并保存到桌面。")
	p.add_argument('-i', '--input', default='.', help='输入图片文件夹（默认当前目录）')
	p.add_argument('-o', '--output', default=None, help='输出文件名（例如 out.pdf），默认写到桌面并带时间戳）')
	p.add_argument('--order', choices=['asc', 'desc'], default='asc', help='按修改时间排序：asc（从旧到新）或 desc（从新到旧）')
	p.add_argument('-r', '--recursive', action='store_true', help='递归查找子目录中的图片')
	return p.parse_args()


def main():
	args = parse_args()

	folder = os.path.abspath(args.input)
	if not os.path.isdir(folder):
		print(f"指定的输入目录不存在：{folder}")
		sys.exit(1)

	images = find_images(folder, recursive=args.recursive)
	if not images:
		print("未在指定文件夹中找到图片。请确认路径和值得处理的图片格式。")
		sys.exit(1)

	# 按修改时间排序
	images.sort(key=lambda p: os.path.getmtime(p), reverse=(args.order == 'desc'))

	# 决定输出路径
	if args.output:
		output_name = args.output
		if not output_name.lower().endswith('.pdf'):
			output_name += '.pdf'
		# 如果用户提供了绝对路径则按绝对路径处理，否则放到桌面
		if os.path.isabs(output_name):
			output_path = output_name
		else:
			output_path = os.path.join(get_desktop_path(), output_name)
		# 自动避免覆盖
		output_path = make_unique_path(output_path)
	else:
		# 自动根据输入文件夹或唯一图片命名
		if os.path.isdir(folder):
			# 如果只有一张图片，用图片名（无扩展）作为基名
			if len(images) == 1:
				base_name = os.path.splitext(os.path.basename(images[0]))[0]
			else:
				base_name = os.path.basename(folder.rstrip(os.sep)) or 'images'
		else:
			base_name = 'images'

		output_name = f"{base_name}.pdf"
		output_path = os.path.join(get_desktop_path(), output_name)
		output_path = make_unique_path(output_path)

	try:
		convert_images_to_pdf(images, output_path)
	except Exception as e:
		print(f"生成 PDF 失败：{e}")
		sys.exit(1)

	print(f"已生成 PDF：{output_path}")


if __name__ == '__main__':
	main()
